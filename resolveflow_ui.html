<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ResolveFlow</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#12141f;--surface:#171928;--surface2:#1c2035;--editor-bg:#1e2235;
  --accent:#e94560;--accent2:#0f3460;--text:#eee;--text2:#8892a8;--text3:#556;
  --green:#4ade80;--green-dark:#16a34a;--orange:#f59e0b;--border:#2a3050;
  --radius:8px;--transition:0.15s ease;
  --clip-colors: #e94560,#3b82f6,#10b981,#f59e0b,#8b5cf6,#ec4899,#06b6d4,#f97316;
}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:var(--bg);color:var(--text);height:100vh;display:flex;flex-direction:column;overflow:hidden}
button{cursor:pointer;font-family:inherit;border:none;border-radius:var(--radius);transition:all var(--transition)}
button:hover{filter:brightness(1.15)}
input,select,textarea{font-family:inherit;background:var(--surface);color:var(--text);border:1px solid var(--border);border-radius:var(--radius);padding:8px 12px;outline:none}
input:focus,select:focus,textarea:focus{border-color:var(--accent)}
::-webkit-scrollbar{width:6px}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
.btn{padding:8px 16px;font-size:13px;font-weight:600;border-radius:var(--radius)}
.btn-accent{background:var(--accent);color:#fff}
.btn-green{background:var(--green-dark);color:#fff}
.btn-secondary{background:var(--surface2);color:var(--text2);border:1px solid var(--border)}
.btn-small{padding:5px 10px;font-size:12px}

/* ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ */
.header{display:flex;align-items:center;padding:10px 20px;background:var(--surface);border-bottom:1px solid var(--border);gap:16px;flex-shrink:0}
.logo{font-size:18px;font-weight:800;color:var(--accent);letter-spacing:-0.5px}
.project-name{color:var(--text2);font-size:13px;margin-right:auto}
.resolve-dot{width:8px;height:8px;border-radius:50%;background:#555;flex-shrink:0}
.resolve-dot.on{background:var(--green)}
.resolve-dot.off{background:var(--accent)}
.resolve-label{font-size:12px;color:var(--text2);margin-right:12px}
.header .btn{margin-left:4px}

/* ‚îÄ‚îÄ MAIN LAYOUT ‚îÄ‚îÄ */
.main{flex:1;display:flex;overflow:hidden}
.editor-area{flex:1;display:flex;flex-direction:column;overflow:hidden;min-width:0}
.sidebar{width:280px;background:var(--surface);border-left:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden;flex-shrink:0}
.sidebar.collapsed{width:0;border:none}
.sidebar-toggle{position:absolute;right:280px;top:60px;z-index:10;background:var(--surface);border:1px solid var(--border);border-right:none;border-radius:var(--radius) 0 0 var(--radius);padding:4px 6px;color:var(--text2);font-size:14px;cursor:pointer}
.sidebar.collapsed+.sidebar-toggle,.sidebar.collapsed~.sidebar-toggle{right:0}

/* ‚îÄ‚îÄ SCRIPT EDITOR ‚îÄ‚îÄ */
.editor-scroll{flex:1;overflow-y:auto;padding:20px 0}
.editor-doc{max-width:800px;margin:0 auto;padding:0 32px}
.no-transcript{text-align:center;color:var(--text2);padding:80px 20px}
.no-transcript h2{margin-bottom:12px;color:var(--text)}
.no-transcript p{margin-bottom:20px;line-height:1.6}

/* Clip section */
.clip-section{margin-bottom:24px;position:relative}
.clip-header{display:flex;align-items:center;gap:10px;padding:8px 12px;margin-bottom:4px;border-radius:var(--radius);background:var(--surface);cursor:grab;user-select:none}
.clip-header.dragging{opacity:0.5}
.clip-header .drag-handle{color:var(--text3);font-size:14px;cursor:grab}
.clip-thumb-small{width:48px;height:28px;border-radius:4px;overflow:hidden;background:var(--surface2);flex-shrink:0}
.clip-thumb-small img{width:100%;height:100%;object-fit:cover}
.clip-header-name{font-size:13px;font-weight:700;flex:1}
.clip-header-dur{font-size:11px;color:var(--text2)}
.clip-header-actions{display:flex;gap:4px}
.clip-header-actions button{background:none;color:var(--text2);font-size:12px;padding:2px 6px}

/* Segment row */
.segment-row{display:flex;align-items:flex-start;gap:0;padding:3px 0;border-radius:4px;transition:background var(--transition);position:relative;cursor:pointer}
.segment-row:hover{background:rgba(255,255,255,0.03)}
.segment-row.selected{background:rgba(233,69,96,0.1)}
.segment-row.excluded{opacity:0.3}
.segment-row.excluded .seg-text{text-decoration:line-through}
.segment-row.drag-over-top{border-top:2px solid var(--accent)}
.segment-row.drag-over-bottom{border-bottom:2px solid var(--accent)}
.seg-tc{width:56px;flex-shrink:0;font-size:11px;color:var(--text3);font-family:'SF Mono',Monaco,Consolas,monospace;padding-top:3px;text-align:right;padding-right:8px;user-select:none}
.seg-check{width:20px;flex-shrink:0;display:flex;align-items:center;justify-content:center;padding-top:2px}
.seg-check input{accent-color:var(--accent);cursor:pointer}
.seg-text{flex:1;font-size:14px;line-height:1.6;padding:1px 4px;color:var(--text)}
.seg-text .filler{background:rgba(245,158,11,0.2);border-radius:2px;padding:0 1px}
.clip-border{width:3px;flex-shrink:0;border-radius:2px;margin-right:6px;align-self:stretch}

/* Tooltip */
.seg-tooltip{position:absolute;left:100%;top:0;margin-left:8px;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:6px 10px;font-size:11px;color:var(--text2);white-space:nowrap;z-index:100;pointer-events:none;display:none}
.segment-row:hover .seg-tooltip{display:block}

/* ‚îÄ‚îÄ SIDEBAR SECTIONS ‚îÄ‚îÄ */
.sidebar-section{padding:14px 16px;border-bottom:1px solid var(--border)}
.sidebar-section h3{font-size:12px;text-transform:uppercase;letter-spacing:0.5px;color:var(--text2);margin-bottom:10px}
.sidebar-section .stat{display:flex;justify-content:space-between;font-size:13px;margin-bottom:6px}
.sidebar-section .stat .val{color:var(--text);font-weight:600}
.clips-list{max-height:200px;overflow-y:auto}
.clips-list-item{display:flex;align-items:center;gap:8px;padding:4px 0;font-size:12px;color:var(--text2)}
.clips-list-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.ai-tools{display:flex;flex-direction:column;gap:6px}
.sidebar-section .btn{width:100%;text-align:center}
.export-tools{display:flex;flex-direction:column;gap:6px}

/* ‚îÄ‚îÄ MINI TIMELINE ‚îÄ‚îÄ */
.mini-timeline{height:40px;background:var(--surface);border-top:1px solid var(--border);flex-shrink:0;display:flex;align-items:center;padding:4px 20px;gap:12px}
.timeline-bar{flex:1;height:24px;background:var(--surface2);border-radius:4px;position:relative;overflow:hidden;cursor:pointer}
.timeline-block{position:absolute;top:0;height:100%;border-radius:2px;transition:opacity var(--transition)}
.timeline-block.excluded{opacity:0.15}
.timeline-duration{font-size:12px;color:var(--text2);white-space:nowrap;flex-shrink:0}

/* ‚îÄ‚îÄ MODAL ‚îÄ‚îÄ */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);z-index:1000;display:none;align-items:center;justify-content:center}
.modal-overlay.show{display:flex}
.modal{background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:24px;width:90%;max-width:480px}
.modal h2{margin-bottom:16px;font-size:18px}
.modal label{display:block;font-size:13px;color:var(--text2);margin-bottom:4px;margin-top:12px}
.modal select,.modal input,.modal textarea{width:100%;margin-bottom:4px}
.modal textarea{height:80px;resize:vertical}
.modal-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:20px}

/* ‚îÄ‚îÄ TOAST ‚îÄ‚îÄ */
.toast{position:fixed;bottom:60px;left:50%;transform:translateX(-50%);background:var(--green-dark);color:#fff;padding:10px 20px;border-radius:var(--radius);font-size:14px;font-weight:600;z-index:2000;opacity:0;transition:opacity 0.3s;pointer-events:none}
.toast.show{opacity:1}
.toast.error{background:var(--accent)}

/* ‚îÄ‚îÄ LOADING ‚îÄ‚îÄ */
.loading-bar{height:3px;background:var(--accent);position:absolute;top:0;left:0;width:0;transition:width 0.3s;z-index:100}
.loading-bar.active{animation:loading 2s infinite}
@keyframes loading{0%{width:0}50%{width:60%}100%{width:100%}}

@media(max-width:768px){
  .sidebar{position:fixed;right:0;top:50px;bottom:40px;z-index:50;width:100%;max-width:320px;transform:translateX(100%);transition:transform 0.2s}
  .sidebar.open{transform:translateX(0)}
  .editor-doc{padding:0 16px}
}
</style>
</head>
<body>

<!-- Header -->
<div class="header">
  <div class="logo">ResolveFlow</div>
  <div class="project-name" id="projectName">Loading...</div>
  <div class="resolve-dot" id="resolveDot"></div>
  <span class="resolve-label" id="resolveLabel">Checking...</span>
  <button class="btn btn-secondary" onclick="transcribeAll()" id="btnTranscribe">Transcribe All</button>
  <button class="btn btn-accent" onclick="showAIModal()" id="btnAI">AI Generate</button>
  <button class="btn btn-green" onclick="sendToResolve()" id="btnResolve">‚è© Send to Resolve</button>
</div>

<div class="loading-bar" id="loadingBar"></div>

<!-- Main -->
<div class="main">
  <!-- Editor Area -->
  <div class="editor-area">
    <div class="editor-scroll" id="editorScroll">
      <div class="editor-doc" id="editorDoc">
        <div class="no-transcript" id="emptyState">
          <h2>No Transcript Yet</h2>
          <p>Click <strong>Transcribe All</strong> to generate transcripts from your clips,<br>
          or use <strong>AI Generate</strong> to create an AI-powered edit.</p>
          <button class="btn btn-accent" onclick="transcribeAll()">Transcribe All Clips</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Right Sidebar -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-section">
      <h3>Script Info</h3>
      <div class="stat"><span>Duration</span><span class="val" id="statDuration">0:00</span></div>
      <div class="stat"><span>Word Count</span><span class="val" id="statWords">0</span></div>
      <div class="stat"><span>Segments</span><span class="val" id="statSegments">0 / 0</span></div>
    </div>
    <div class="sidebar-section">
      <h3>Clips Used</h3>
      <div class="clips-list" id="clipsList"></div>
    </div>
    <div class="sidebar-section">
      <h3>AI Tools</h3>
      <div class="ai-tools">
        <button class="btn btn-accent" onclick="showAIModal()">‚ú® AI Generate Script</button>
        <button class="btn btn-secondary" onclick="aiTighten()">‚úÇÔ∏è Tighten Edit</button>
        <button class="btn btn-secondary" onclick="removeSilences()">üîá Remove Silences</button>
        <button class="btn btn-secondary" onclick="removeFillerWords()">üóëÔ∏è Remove Filler Words</button>
      </div>
    </div>
    <div class="sidebar-section">
      <h3>Export</h3>
      <div class="export-tools">
        <button class="btn btn-green" onclick="sendToResolve()">‚è© Send to Resolve</button>
        <button class="btn btn-secondary" onclick="exportEDL()">üìÑ Export EDL</button>
        <button class="btn btn-secondary" onclick="exportText()">üìù Export Text</button>
      </div>
    </div>
  </div>
</div>

<!-- Mini Timeline -->
<div class="mini-timeline">
  <div class="timeline-bar" id="timelineBar"></div>
  <div class="timeline-duration" id="timelineDuration">0:00</div>
</div>

<!-- AI Modal -->
<div class="modal-overlay" id="aiModal">
  <div class="modal">
    <h2>‚ú® AI Generate Script</h2>
    <label>Target Duration</label>
    <select id="aiDuration">
      <option value="30">30 seconds</option>
      <option value="60">1 minute</option>
      <option value="120" selected>2 minutes</option>
      <option value="300">5 minutes</option>
      <option value="600">10 minutes</option>
    </select>
    <label>Style</label>
    <select id="aiStyle">
      <option value="highlight reel">Highlight Reel</option>
      <option value="narrative documentary">Narrative Documentary</option>
      <option value="fast-paced montage">Fast-Paced Montage</option>
      <option value="interview edit">Interview Edit</option>
      <option value="social media short">Social Media Short</option>
    </select>
    <label>Custom Prompt (optional)</label>
    <textarea id="aiPrompt" placeholder="Any specific instructions..."></textarea>
    <div class="modal-actions">
      <button class="btn btn-secondary" onclick="closeAIModal()">Cancel</button>
      <button class="btn btn-accent" onclick="runAIGenerate()">Generate</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ‚îÄ‚îÄ STATE ‚îÄ‚îÄ
let allSegments = [];   // {id, clip_id, text, start_time, end_time, filename, included, clip_color}
let clipColors = {};
let clipMeta = {};      // clip_id -> {filename, duration, thumbnail}
let selectedSegIds = new Set();
let lastClickedIdx = null;
let currentScriptId = null;

const CLIP_PALETTE = ['#e94560','#3b82f6','#10b981','#f59e0b','#8b5cf6','#ec4899','#06b6d4','#f97316','#84cc16','#ef4444','#14b8a6','#a855f7'];
const FILLER_WORDS = /^(um+|uh+|uh huh|hmm+|like|you know|basically|actually|so|right|i mean|well|okay|yeah)[\.\,\!\?]?$/i;
const FILLER_PATTERN = /\b(um+|uh+|hmm+|like|you know|basically|actually|i mean)\b/gi;

// ‚îÄ‚îÄ INIT ‚îÄ‚îÄ
async function init() {
  await Promise.all([loadProject(), checkResolve()]);
  await loadClips();
  await loadTranscripts();
  renderEditor();
  updateStats();
  renderTimeline();
}

async function api(path, opts) {
  const r = await fetch('/api/' + path, opts);
  return r.json();
}

async function loadProject() {
  const p = await api('project');
  document.getElementById('projectName').textContent = p.name || 'Unknown';
}

async function checkResolve() {
  try {
    const s = await api('resolve/status');
    const dot = document.getElementById('resolveDot');
    const label = document.getElementById('resolveLabel');
    if (s.connected) {
      dot.className = 'resolve-dot on';
      label.textContent = s.project || 'Connected';
    } else {
      dot.className = 'resolve-dot off';
      label.textContent = 'Not connected';
    }
  } catch(e) {
    document.getElementById('resolveDot').className = 'resolve-dot off';
    document.getElementById('resolveLabel').textContent = 'Offline';
  }
}

async function loadClips() {
  const clips = await api('clips');
  let ci = 0;
  for (const c of clips) {
    if (!clipColors[c.id]) {
      clipColors[c.id] = CLIP_PALETTE[ci % CLIP_PALETTE.length];
      ci++;
    }
    clipMeta[c.id] = { filename: c.filename, duration: c.duration_seconds, thumbnail: c.thumbnail_path ? true : false, has_transcript: c.has_transcript };
  }
}

async function loadTranscripts() {
  const segs = await api('transcript/full');
  allSegments = segs.map((s, i) => ({
    id: s.id,
    clip_id: s.clip_id,
    text: s.text,
    start_time: s.start_time,
    end_time: s.end_time,
    filename: s.filename,
    included: true,
    order: i,
    clip_color: clipColors[s.clip_id] || '#666'
  }));
}

// ‚îÄ‚îÄ FORMAT HELPERS ‚îÄ‚îÄ
function fmtTC(sec) {
  if (sec == null) return '0:00';
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${s.toString().padStart(2, '0')}`;
}

function highlightFillers(text) {
  return text.replace(FILLER_PATTERN, '<span class="filler">$1</span>');
}

function isFillerSegment(text) {
  return FILLER_WORDS.test(text.trim());
}

// ‚îÄ‚îÄ RENDER EDITOR ‚îÄ‚îÄ
function renderEditor() {
  const doc = document.getElementById('editorDoc');
  const empty = document.getElementById('emptyState');

  if (allSegments.length === 0) {
    empty.style.display = '';
    return;
  }
  empty.style.display = 'none';

  // Group by clip in order
  const groups = [];
  let currentClip = null;
  for (const seg of allSegments) {
    if (seg.clip_id !== currentClip) {
      groups.push({ clip_id: seg.clip_id, filename: seg.filename, segments: [] });
      currentClip = seg.clip_id;
    }
    groups[groups.length - 1].segments.push(seg);
  }

  let html = '';
  for (const g of groups) {
    const color = clipColors[g.clip_id] || '#666';
    const meta = clipMeta[g.clip_id] || {};
    const includedDur = g.segments.filter(s => s.included).reduce((a, s) => a + (s.end_time - s.start_time), 0);

    html += `<div class="clip-section" data-clip-id="${g.clip_id}" draggable="true" ondragstart="dragClipStart(event, ${g.clip_id})" ondragover="dragClipOver(event)" ondrop="dropClip(event, ${g.clip_id})">`;
    html += `<div class="clip-header" style="border-left:3px solid ${color}">`;
    html += `<span class="drag-handle">‚†ø</span>`;
    html += `<div class="clip-thumb-small"><img src="/api/thumbnails/${g.clip_id}" onerror="this.parentElement.textContent='üé¨'"></div>`;
    html += `<span class="clip-header-name" style="color:${color}">${g.filename}</span>`;
    html += `<span class="clip-header-dur">${fmtTC(includedDur)}</span>`;
    html += `<div class="clip-header-actions">`;
    html += `<button onclick="toggleClip(${g.clip_id}, true)" title="Include all">‚òëÔ∏è</button>`;
    html += `<button onclick="toggleClip(${g.clip_id}, false)" title="Exclude all">‚òê</button>`;
    html += `</div></div>`;

    for (const seg of g.segments) {
      const idx = allSegments.indexOf(seg);
      const sel = selectedSegIds.has(seg.id) ? ' selected' : '';
      const exc = !seg.included ? ' excluded' : '';
      html += `<div class="segment-row${sel}${exc}" data-seg-id="${seg.id}" data-idx="${idx}" onclick="clickSegment(event, ${idx})">`;
      html += `<div class="clip-border" style="background:${color}"></div>`;
      html += `<div class="seg-tc">${fmtTC(seg.start_time)}</div>`;
      html += `<div class="seg-check"><input type="checkbox" ${seg.included ? 'checked' : ''} onclick="event.stopPropagation();toggleSegment(${idx})" tabindex="-1"></div>`;
      html += `<div class="seg-text">${highlightFillers(seg.text)}</div>`;
      html += `<div class="seg-tooltip">${seg.filename} ¬∑ ${fmtTC(seg.start_time)} ‚Äì ${fmtTC(seg.end_time)}</div>`;
      html += `</div>`;
    }
    html += `</div>`;
  }

  doc.innerHTML = html;
}

// ‚îÄ‚îÄ SEGMENT INTERACTIONS ‚îÄ‚îÄ
function toggleSegment(idx) {
  allSegments[idx].included = !allSegments[idx].included;
  renderEditor();
  updateStats();
  renderTimeline();
}

function clickSegment(event, idx) {
  if (event.target.type === 'checkbox') return;
  const seg = allSegments[idx];

  if (event.shiftKey && lastClickedIdx !== null) {
    const from = Math.min(lastClickedIdx, idx);
    const to = Math.max(lastClickedIdx, idx);
    for (let i = from; i <= to; i++) selectedSegIds.add(allSegments[i].id);
  } else if (event.metaKey || event.ctrlKey) {
    if (selectedSegIds.has(seg.id)) selectedSegIds.delete(seg.id);
    else selectedSegIds.add(seg.id);
  } else {
    selectedSegIds.clear();
    selectedSegIds.add(seg.id);
  }
  lastClickedIdx = idx;
  renderEditor();
}

function toggleClip(clipId, include) {
  for (const s of allSegments) {
    if (s.clip_id === clipId) s.included = include;
  }
  renderEditor();
  updateStats();
  renderTimeline();
}

function batchSetSelected(include) {
  for (const s of allSegments) {
    if (selectedSegIds.has(s.id)) s.included = include;
  }
  renderEditor();
  updateStats();
  renderTimeline();
}

// ‚îÄ‚îÄ DRAG CLIP SECTIONS ‚îÄ‚îÄ
let dragClipId = null;
function dragClipStart(e, clipId) {
  dragClipId = clipId;
  e.dataTransfer.effectAllowed = 'move';
}
function dragClipOver(e) { e.preventDefault(); }
function dropClip(e, targetClipId) {
  e.preventDefault();
  if (dragClipId === null || dragClipId === targetClipId) return;
  // Reorder: move all segments of dragClipId before targetClipId
  const dragged = allSegments.filter(s => s.clip_id === dragClipId);
  const rest = allSegments.filter(s => s.clip_id !== dragClipId);
  const insertIdx = rest.findIndex(s => s.clip_id === targetClipId);
  rest.splice(insertIdx, 0, ...dragged);
  allSegments = rest;
  dragClipId = null;
  renderEditor();
  renderTimeline();
}

// ‚îÄ‚îÄ KEYBOARD ‚îÄ‚îÄ
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
  if ((e.key === 'Delete' || e.key === 'Backspace') && selectedSegIds.size > 0) {
    e.preventDefault();
    batchSetSelected(false);
  }
  if (e.key === 'a' && (e.metaKey || e.ctrlKey)) {
    e.preventDefault();
    allSegments.forEach(s => selectedSegIds.add(s.id));
    renderEditor();
  }
  if (e.key === 'i' && selectedSegIds.size > 0) batchSetSelected(true);
  if (e.key === 'x' && selectedSegIds.size > 0) batchSetSelected(false);
});

// ‚îÄ‚îÄ STATS ‚îÄ‚îÄ
function updateStats() {
  const included = allSegments.filter(s => s.included);
  const totalDur = included.reduce((a, s) => a + (s.end_time - s.start_time), 0);
  const wordCount = included.reduce((a, s) => a + s.text.split(/\s+/).filter(Boolean).length, 0);

  document.getElementById('statDuration').textContent = fmtTC(totalDur);
  document.getElementById('statWords').textContent = wordCount.toLocaleString();
  document.getElementById('statSegments').textContent = `${included.length} / ${allSegments.length}`;
  document.getElementById('timelineDuration').textContent = fmtTC(totalDur);

  // Clips list
  const byClip = {};
  for (const s of included) {
    if (!byClip[s.clip_id]) byClip[s.clip_id] = { filename: s.filename, dur: 0 };
    byClip[s.clip_id].dur += s.end_time - s.start_time;
  }
  const cl = document.getElementById('clipsList');
  cl.innerHTML = Object.entries(byClip).map(([id, c]) =>
    `<div class="clips-list-item"><div class="clips-list-dot" style="background:${clipColors[id]||'#666'}"></div>${c.filename}<span style="margin-left:auto;color:var(--text2)">${fmtTC(c.dur)}</span></div>`
  ).join('') || '<div style="font-size:12px;color:var(--text3)">No clips included</div>';
}

// ‚îÄ‚îÄ MINI TIMELINE ‚îÄ‚îÄ
function renderTimeline() {
  const bar = document.getElementById('timelineBar');
  const totalDur = allSegments.reduce((a, s) => a + (s.end_time - s.start_time), 0);
  if (totalDur === 0) { bar.innerHTML = ''; return; }

  let html = '';
  let pos = 0;
  for (const s of allSegments) {
    const dur = s.end_time - s.start_time;
    const left = (pos / totalDur * 100);
    const width = (dur / totalDur * 100);
    const exc = s.included ? '' : ' excluded';
    html += `<div class="timeline-block${exc}" style="left:${left}%;width:${width}%;background:${s.clip_color}" title="${s.filename} ${fmtTC(s.start_time)}"></div>`;
    pos += dur;
  }
  bar.innerHTML = html;
}

// ‚îÄ‚îÄ TRANSCRIBE ‚îÄ‚îÄ
async function transcribeAll() {
  const btn = document.getElementById('btnTranscribe');
  btn.textContent = '‚è≥ Transcribing...';
  btn.disabled = true;
  showLoading(true);

  try {
    // Try whisper first (works without Resolve)
    await api('transcribe', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({method:'whisper'}) });
    toast('Transcription started ‚Äî this may take a few minutes');
    // Poll progress
    pollTranscription();
  } catch(e) {
    toast('Transcription failed: ' + e.message, true);
    btn.textContent = 'Transcribe All';
    btn.disabled = false;
    showLoading(false);
  }
}

async function pollTranscription() {
  const btn = document.getElementById('btnTranscribe');
  const check = async () => {
    const p = await api('transcribe/progress');
    if (p.running) {
      btn.textContent = `‚è≥ ${p.done}/${p.total}`;
      setTimeout(check, 3000);
    } else {
      btn.textContent = 'Transcribe All';
      btn.disabled = false;
      showLoading(false);
      await loadTranscripts();
      renderEditor();
      updateStats();
      renderTimeline();
      toast('Transcription complete!');
    }
  };
  setTimeout(check, 3000);
}

// ‚îÄ‚îÄ FILLER WORDS ‚îÄ‚îÄ
function removeFillerWords() {
  let count = 0;
  for (const s of allSegments) {
    if (s.included && isFillerSegment(s.text)) {
      s.included = false;
      count++;
    }
  }
  renderEditor();
  updateStats();
  renderTimeline();
  toast(`Removed ${count} filler word segments`);
}

function removeSilences() {
  let count = 0;
  for (const s of allSegments) {
    if (s.included && s.text.trim().length === 0) {
      s.included = false;
      count++;
    }
  }
  renderEditor();
  updateStats();
  renderTimeline();
  toast(`Removed ${count} silent segments`);
}

// ‚îÄ‚îÄ AI ‚îÄ‚îÄ
function showAIModal() { document.getElementById('aiModal').classList.add('show'); }
function closeAIModal() { document.getElementById('aiModal').classList.remove('show'); }

async function runAIGenerate() {
  closeAIModal();
  showLoading(true);
  toast('AI is generating your edit...');
  try {
    const result = await api('ai/auto-edit', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({
        target_duration: parseInt(document.getElementById('aiDuration').value),
        style: document.getElementById('aiStyle').value,
        script_id: currentScriptId
      })
    });
    if (result.error) { toast(result.error, true); showLoading(false); return; }
    currentScriptId = result.script_id;
    // Apply AI decisions to segments
    if (result.sections) {
      applyAISections(result.sections);
    }
    showLoading(false);
    toast(`AI generated ${result.section_count} sections`);
  } catch(e) {
    toast('AI generation failed', true);
    showLoading(false);
  }
}

function applyAISections(sections) {
  // Mark all as excluded first
  allSegments.forEach(s => s.included = false);
  // Include segments that fall within AI sections
  for (const sec of sections) {
    for (const s of allSegments) {
      if (s.clip_id === sec.clip_id && s.start_time >= sec.start_time - 0.5 && s.end_time <= sec.end_time + 0.5) {
        s.included = true;
      }
    }
  }
  renderEditor();
  updateStats();
  renderTimeline();
}

async function aiTighten() {
  showLoading(true);
  toast('AI is tightening your edit...');
  try {
    const included = allSegments.filter(s => s.included);
    const text = included.map(s => `[${s.id}] ${s.text}`).join('\n');
    const result = await api('ai/brainstorm', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ prompt: `Given this transcript, identify segment IDs that are redundant, repetitive, or could be cut to make the edit tighter and more engaging. Return ONLY a JSON array of segment IDs to REMOVE. Transcript:\n${text}` })
    });
    if (result.suggestions) {
      try {
        const match = result.suggestions.match(/\[[\d,\s]+\]/);
        if (match) {
          const removeIds = new Set(JSON.parse(match[0]));
          let removed = 0;
          for (const s of allSegments) {
            if (removeIds.has(s.id)) { s.included = false; removed++; }
          }
          renderEditor(); updateStats(); renderTimeline();
          toast(`AI removed ${removed} redundant segments`);
        }
      } catch(e) { toast('AI response unclear ‚Äî try again', true); }
    }
  } catch(e) { toast('Tighten failed', true); }
  showLoading(false);
}

// ‚îÄ‚îÄ EXPORT ‚îÄ‚îÄ
async function sendToResolve() {
  const included = allSegments.filter(s => s.included);
  if (included.length === 0) { toast('No segments to export', true); return; }

  showLoading(true);
  try {
    // Create/update script with current segments
    if (!currentScriptId) {
      const r = await api('scripts', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ name: 'ResolveFlow Edit ' + new Date().toLocaleDateString() })
      });
      currentScriptId = r.id;
    }

    // Update script segments via new endpoint
    await api(`script/${currentScriptId}/update-segments`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ segments: buildExportSegments() })
    });

    // Export to Resolve
    const result = await api(`export/resolve/${currentScriptId}`, { method: 'POST' });
    if (result.error) { toast(result.error, true); }
    else { toast(`‚úÖ Sent to Resolve: "${result.timeline_name}" (${result.segments_added} clips)`); }
  } catch(e) { toast('Export failed: ' + e.message, true); }
  showLoading(false);
}

function buildExportSegments() {
  const included = allSegments.filter(s => s.included);
  // Group consecutive same-clip segments
  const groups = [];
  for (const s of included) {
    const last = groups[groups.length - 1];
    if (last && last.clip_id === s.clip_id && Math.abs(s.start_time - last.end_time) < 0.5) {
      last.end_time = s.end_time;
      last.text += ' ' + s.text;
    } else {
      groups.push({ clip_id: s.clip_id, start_time: s.start_time, end_time: s.end_time, text: s.text, section_name: s.filename });
    }
  }
  return groups.map((g, i) => ({
    clip_id: g.clip_id,
    start_time: g.start_time,
    end_time: g.end_time,
    section_name: g.section_name,
    order_index: i
  }));
}

async function exportEDL() {
  if (!currentScriptId) {
    // Create script first
    const r = await api('scripts', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ name: 'ResolveFlow Edit' })
    });
    currentScriptId = r.id;
    await api(`script/${currentScriptId}/update-segments`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ segments: buildExportSegments() })
    });
  }
  window.open(`/api/export/edl/${currentScriptId}`, '_blank');
}

function exportText() {
  const included = allSegments.filter(s => s.included);
  const text = included.map(s => s.text).join('\n');
  const blob = new Blob([text], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'resolveflow-script.txt';
  a.click();
}

// ‚îÄ‚îÄ UI HELPERS ‚îÄ‚îÄ
function toast(msg, isError) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.className = 'toast show' + (isError ? ' error' : '');
  setTimeout(() => t.className = 'toast', 3000);
}

function showLoading(on) {
  document.getElementById('loadingBar').className = 'loading-bar' + (on ? ' active' : '');
}

// ‚îÄ‚îÄ START ‚îÄ‚îÄ
init();
// Refresh Resolve status every 30s
setInterval(checkResolve, 30000);
</script>
</body>
</html>
