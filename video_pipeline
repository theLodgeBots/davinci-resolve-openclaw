#!/usr/bin/env python3
"""Video editing pipeline CLI wrapper for OpenClaw integration."""

import argparse
import json
import os
import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.absolute()
sys.path.insert(0, str(project_root))

from ingest import scan_folder, save_manifest
from transcribe import transcribe_project
from script_engine import generate_edit_plan
from script_engine_enhanced import generate_enhanced_edit_plan
from timeline_builder import build_timeline_from_plan
from analyze_usage import analyze_clip_usage
from resolve_bridge import get_resolve
from scene_detection import analyze_project_scenes, save_scene_analysis
from auto_export import render_timeline, render_project_timelines, RENDER_PRESETS
from script_engine_ai import generate_ai_enhanced_edit_plan

def main():
    parser = argparse.ArgumentParser(description="AI Video Editing Pipeline")
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Full pipeline command
    pipeline = subparsers.add_parser('pipeline', help='Run complete editing pipeline')
    pipeline.add_argument('folder', help='Path to folder containing video files')
    pipeline.add_argument('--style', choices=['basic', 'enhanced', 'ai'], default='enhanced', 
                         help='Edit style: basic, enhanced, or ai (with scene analysis)')
    pipeline.add_argument('--project-name', help='Custom DaVinci Resolve project name')
    pipeline.add_argument('--dry-run', action='store_true', help='Skip timeline building')
    
    # Individual commands
    ingest = subparsers.add_parser('ingest', help='Scan folder and extract metadata')
    ingest.add_argument('folder', help='Path to folder containing video files')
    
    transcribe = subparsers.add_parser('transcribe', help='Generate transcripts')
    transcribe.add_argument('manifest', help='Path to manifest.json file')
    
    script = subparsers.add_parser('script', help='Generate edit plan')
    script.add_argument('manifest', help='Path to manifest.json file')
    script.add_argument('transcripts', help='Path to transcripts directory')
    script.add_argument('--style', choices=['basic', 'enhanced', 'ai'], default='enhanced')
    script.add_argument('--output', help='Custom output path for edit plan')
    
    timeline = subparsers.add_parser('timeline', help='Build DaVinci Resolve timeline')
    timeline.add_argument('edit_plan', help='Path to edit_plan.json file')
    timeline.add_argument('manifest', help='Path to manifest.json file')
    timeline.add_argument('--project-name', help='Custom project name')
    
    analyze = subparsers.add_parser('analyze', help='Analyze footage usage')
    analyze.add_argument('manifest', help='Path to manifest.json file')
    analyze.add_argument('edit_plan', help='Path to edit_plan.json file')
    
    status = subparsers.add_parser('status', help='Check system status')
    
    # Phase 5 enhancements
    scenes = subparsers.add_parser('scenes', help='Analyze shot types and scene classification')
    scenes.add_argument('manifest', help='Path to manifest.json file')
    
    export = subparsers.add_parser('export', help='Auto-render and export timeline')
    export.add_argument('project', help='DaVinci Resolve project name')
    export.add_argument('timeline', help='Timeline name (or --all for all timelines)')
    export.add_argument('--preset', choices=list(RENDER_PRESETS.keys()), default='youtube_1080p',
                       help='Render preset (default: youtube_1080p)')
    export.add_argument('--output', help='Custom output directory')
    export.add_argument('--no-wait', action='store_true', help='Start render without waiting for completion')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    try:
        if args.command == 'status':
            return cmd_status()
        elif args.command == 'ingest':
            return cmd_ingest(args.folder)
        elif args.command == 'transcribe':
            return cmd_transcribe(args.manifest)
        elif args.command == 'script':
            return cmd_script(args.manifest, args.transcripts, args.style, args.output)
        elif args.command == 'timeline':
            return cmd_timeline(args.edit_plan, args.manifest, args.project_name)
        elif args.command == 'analyze':
            return cmd_analyze(args.manifest, args.edit_plan)
        elif args.command == 'pipeline':
            return cmd_pipeline(args.folder, args.style, args.project_name, args.dry_run)
        elif args.command == 'scenes':
            return cmd_scenes(args.manifest)
        elif args.command == 'export':
            return cmd_export(args.project, args.timeline, args.preset, args.output, not args.no_wait)
    except Exception as e:
        print(f"âŒ Error: {e}", file=sys.stderr)
        return 1

def cmd_status():
    """Check system prerequisites."""
    print("ğŸ¬ DaVinci Resolve Video Pipeline Status")
    print("=" * 40)
    
    # Check DaVinci Resolve
    resolve = get_resolve()
    if resolve:
        try:
            project = resolve.GetProjectManager().GetCurrentProject()
            project_name = project.GetName() if project else "None"
            print(f"âœ… DaVinci Resolve: Connected")
            print(f"   Current project: {project_name}")
        except Exception as e:
            print(f"âš ï¸  DaVinci Resolve: Connected but error getting project: {e}")
    else:
        print("âŒ DaVinci Resolve: Not running or not accessible")
    
    # Check OpenAI API key
    api_key = os.getenv('OPENAI_API_KEY')
    if api_key:
        print(f"âœ… OpenAI API: Key configured ({api_key[:8]}...)")
    else:
        print("âŒ OpenAI API: No API key found (set OPENAI_API_KEY)")
    
    # Check ffprobe
    if os.system('which ffprobe > /dev/null 2>&1') == 0:
        print("âœ… ffprobe: Available")
    else:
        print("âŒ ffprobe: Not found (install with 'brew install ffmpeg')")
    
    return 0

def cmd_ingest(folder_path):
    """Ingest footage from folder."""
    if not os.path.exists(folder_path):
        raise FileNotFoundError(f"Folder not found: {folder_path}")
    
    print(f"ğŸ“ Scanning folder: {folder_path}")
    manifest = scan_folder(folder_path)
    manifest_path = os.path.join(folder_path, "manifest.json")
    save_manifest(manifest, manifest_path)
    
    print(f"âœ… Ingested {manifest['total_clips']} clips ({manifest['total_duration_minutes']:.1f} min)")
    print(f"   Manifest saved: {manifest_path}")
    return 0

def cmd_transcribe(manifest_path):
    """Generate transcripts."""
    if not os.path.exists(manifest_path):
        raise FileNotFoundError(f"Manifest not found: {manifest_path}")
    
    print(f"ğŸ¤ Transcribing audio from: {manifest_path}")
    transcripts = transcribe_project(manifest_path)
    
    success_count = len([t for t in transcripts.values() if t])
    total_count = len(transcripts)
    
    print(f"âœ… Transcribed {success_count}/{total_count} clips")
    print(f"   Transcripts saved: {os.path.dirname(manifest_path)}/_transcripts/")
    return 0

def cmd_script(manifest_path, transcripts_dir, style, output_path):
    """Generate edit script."""
    if not os.path.exists(manifest_path):
        raise FileNotFoundError(f"Manifest not found: {manifest_path}")
    if not os.path.exists(transcripts_dir):
        raise FileNotFoundError(f"Transcripts directory not found: {transcripts_dir}")
    
    print(f"ğŸ¤– Generating {style} edit script...")
    
    if style == 'ai':
        edit_plan = generate_ai_enhanced_edit_plan(manifest_path, transcripts_dir, output_path)
    elif style == 'enhanced':
        edit_plan = generate_enhanced_edit_plan(manifest_path, transcripts_dir, output_path)
    else:
        edit_plan = generate_edit_plan(manifest_path, transcripts_dir, output_path)
    
    if not edit_plan:
        raise Exception("Failed to generate edit plan")
    
    sections = len(edit_plan.get("sections", []))
    total_clips = sum(len(s.get("clips", [])) for s in edit_plan.get("sections", []))
    broll_clips = sum(1 for s in edit_plan.get("sections", []) for c in s.get("clips", []) if c.get("role") == "broll")
    broll_pct = round(broll_clips/total_clips*100, 1) if total_clips > 0 else 0
    
    print(f"âœ… Generated edit plan: {edit_plan.get('title', 'Untitled')}")
    print(f"   {sections} sections, {total_clips} clips, {broll_pct}% B-roll")
    print(f"   Estimated duration: {edit_plan.get('estimated_duration_seconds', 0)//60:.0f}:{edit_plan.get('estimated_duration_seconds', 0)%60:02.0f}")
    
    final_path = output_path or os.path.join(os.path.dirname(manifest_path), f"edit_plan{'_enhanced' if style=='enhanced' else ''}.json")
    print(f"   Plan saved: {final_path}")
    return 0

def cmd_timeline(edit_plan_path, manifest_path, project_name):
    """Build timeline in DaVinci Resolve."""
    if not os.path.exists(edit_plan_path):
        raise FileNotFoundError(f"Edit plan not found: {edit_plan_path}")
    if not os.path.exists(manifest_path):
        raise FileNotFoundError(f"Manifest not found: {manifest_path}")
    
    # Check Resolve connection
    resolve = get_resolve()
    if not resolve:
        raise Exception("Cannot connect to DaVinci Resolve. Is it running?")
    
    print(f"ğŸ¬ Building timeline from: {edit_plan_path}")
    timeline = build_timeline_from_plan(edit_plan_path, manifest_path, project_name)
    
    if timeline:
        print(f"âœ… Timeline created: {timeline.GetName()}")
        print(f"   Video tracks: {timeline.GetTrackCount('video')}")
        print(f"   Audio tracks: {timeline.GetTrackCount('audio')}")
    else:
        raise Exception("Failed to create timeline")
    
    return 0

def cmd_analyze(manifest_path, edit_plan_path):
    """Analyze footage usage."""
    if not os.path.exists(manifest_path):
        raise FileNotFoundError(f"Manifest not found: {manifest_path}")
    if not os.path.exists(edit_plan_path):
        raise FileNotFoundError(f"Edit plan not found: {edit_plan_path}")
    
    # Load data for basic analysis
    with open(manifest_path) as f:
        manifest = json.load(f)
    with open(edit_plan_path) as f:
        plan = json.load(f)
    
    all_clips = len(manifest["clips"])
    used_clips = set()
    for section in plan.get("sections", []):
        for clip_info in section.get("clips", []):
            used_clips.add(clip_info["filename"])
    
    unused_count = all_clips - len(used_clips)
    usage_pct = round(len(used_clips)/all_clips*100, 1)
    
    print(f"ğŸ“Š Footage Usage Analysis")
    print(f"   Total clips: {all_clips}")
    print(f"   Used clips: {len(used_clips)} ({usage_pct}%)")
    print(f"   Unused clips: {unused_count}")
    
    if unused_count > 0:
        print(f"   ğŸ’¡ {unused_count} clips available for additional B-roll!")
    
    return 0

def cmd_pipeline(folder_path, style, project_name, dry_run):
    """Run complete pipeline."""
    if not os.path.exists(folder_path):
        raise FileNotFoundError(f"Folder not found: {folder_path}")
    
    print(f"ğŸš€ Starting {style} video editing pipeline...")
    print(f"   Source: {folder_path}")
    if project_name:
        print(f"   Project: {project_name}")
    if dry_run:
        print("   Mode: Dry run (no timeline creation)")
    print()
    
    # Step 1: Ingest
    print("Step 1/4: Ingesting footage...")
    manifest_path = os.path.join(folder_path, "manifest.json")
    if not os.path.exists(manifest_path):
        cmd_ingest(folder_path)
    else:
        print(f"   Using existing manifest: {manifest_path}")
    
    # Step 2: Transcribe  
    print("\nStep 2/4: Transcribing audio...")
    transcripts_dir = os.path.join(folder_path, "_transcripts")
    if not os.path.exists(transcripts_dir):
        cmd_transcribe(manifest_path)
    else:
        print(f"   Using existing transcripts: {transcripts_dir}")
    
    # Step 2.5: Scene analysis (if using AI style)
    if style == 'ai':
        scene_analysis_path = os.path.join(folder_path, "scene_analysis.json")
        if not os.path.exists(scene_analysis_path):
            print(f"\nStep 2.5/5: Analyzing scenes for AI enhancement...")
            cmd_scenes(manifest_path)
        else:
            print(f"\nStep 2.5/5: Using existing scene analysis: {scene_analysis_path}")
    
    # Step 3: Generate script
    step_num = "3/5" if style == 'ai' else "3/4"
    print(f"\nStep {step_num}: Generating {style} edit script...")
    suffix = '_ai_enhanced' if style == 'ai' else ('_enhanced' if style == 'enhanced' else '')
    edit_plan_path = os.path.join(folder_path, f"edit_plan{suffix}.json")
    if not os.path.exists(edit_plan_path):
        cmd_script(manifest_path, transcripts_dir, style, edit_plan_path)
    else:
        print(f"   Using existing edit plan: {edit_plan_path}")
    
    # Step 4: Build timeline
    step_num = "4/5" if style == 'ai' else "4/4"
    if dry_run:
        print(f"\nStep {step_num}: Skipping timeline creation (dry run)")
    else:
        print(f"\nStep {step_num}: Building DaVinci Resolve timeline...")
        cmd_timeline(edit_plan_path, manifest_path, project_name)
    
    # Summary
    print("\nğŸ‰ Pipeline complete!")
    with open(manifest_path) as f:
        manifest = json.load(f)
    
    print(f"   ğŸ“ Processed {manifest['total_clips']} clips ({manifest['total_duration_minutes']:.1f} min)")
    print(f"   ğŸ¬ Timeline ready in DaVinci Resolve")
    print(f"   ğŸ“‹ Next: Review, adjust, and export your video!")
    
    return 0

def cmd_scenes(manifest_path):
    """Analyze scenes and shot types."""
    if not os.path.exists(manifest_path):
        raise FileNotFoundError(f"Manifest not found: {manifest_path}")
    
    print(f"ğŸ¯ Analyzing scenes from: {manifest_path}")
    
    # Check OpenAI API key
    api_key = os.getenv('OPENAI_API_KEY')
    if not api_key:
        raise Exception("OpenAI API key not found (set OPENAI_API_KEY)")
    
    analysis = analyze_project_scenes(manifest_path)
    
    if "error" in analysis:
        raise Exception(f"Scene analysis failed: {analysis['error']}")
    
    # Save results
    output_path = os.path.join(os.path.dirname(manifest_path), "scene_analysis.json")
    save_scene_analysis(analysis, output_path)
    
    # Print summary
    summary = analysis.get("scene_summary", {})
    print(f"âœ… Analyzed {analysis['analyzed_clips']}/{analysis['total_clips']} clips")
    print(f"   Shot scales: {summary.get('shot_scale_distribution', {})}")
    print(f"   Movements: {summary.get('movement_distribution', {})}")
    print(f"   Subjects: {summary.get('subject_distribution', {})}")
    
    if analysis["failed_clips"] > 0:
        print(f"âš ï¸  {analysis['failed_clips']} clips failed analysis")
    
    print(f"   Results saved: {output_path}")
    return 0

def cmd_export(project_name, timeline_name, preset, output_dir, wait):
    """Export timeline(s) from DaVinci Resolve."""
    # Check Resolve connection
    resolve = get_resolve()
    if not resolve:
        raise Exception("Cannot connect to DaVinci Resolve. Is it running?")
    
    print(f"ğŸ¬ Exporting from project: {project_name}")
    print(f"   Timeline: {timeline_name}")
    print(f"   Preset: {RENDER_PRESETS[preset]['description']}")
    if output_dir:
        print(f"   Output: {output_dir}")
    
    try:
        if timeline_name == "--all":
            # Render all timelines
            result = render_project_timelines(project_name, preset, output_dir)
            
            if result.get("error"):
                raise Exception(result["error"])
            
            print(f"\nğŸ“Š Export Summary:")
            print(f"   Success: {result['rendered_timelines']}/{result['total_timelines']}")
            
            if result['failed_timelines'] > 0:
                print(f"   Failed: {result['failed_timelines']}")
                return 1
        else:
            # Render single timeline
            result = render_timeline(project_name, timeline_name, preset, output_dir, wait)
            
            if result.get("error"):
                raise Exception(result["error"])
            
            if result.get("status") == "complete":
                print(f"âœ… Export complete!")
                if result.get("filename"):
                    print(f"   File: {result['filename']}")
            elif result.get("status") == "started":
                print(f"âœ… Render started (job ID: {result.get('job_id')})")
                print(f"ğŸ’¡ Use DaVinci Resolve's render queue to monitor progress")
            else:
                print(f"âš ï¸  Render status: {result.get('status', 'unknown')}")
    
    except Exception as e:
        raise Exception(f"Export failed: {e}")
    
    return 0

if __name__ == '__main__':
    exit(main())