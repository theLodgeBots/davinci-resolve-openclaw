#!/usr/bin/env python3
"""Video editing pipeline CLI wrapper for OpenClaw integration."""

import argparse
import json
import os
import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.absolute()
sys.path.insert(0, str(project_root))

from ingest import scan_folder, save_manifest
from transcribe import transcribe_project
from script_engine import generate_edit_plan
from script_engine_enhanced import generate_enhanced_edit_plan
from timeline_builder import build_timeline_from_plan
from analyze_usage import analyze_clip_usage
from resolve_bridge import get_resolve

def main():
    parser = argparse.ArgumentParser(description="AI Video Editing Pipeline")
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Full pipeline command
    pipeline = subparsers.add_parser('pipeline', help='Run complete editing pipeline')
    pipeline.add_argument('folder', help='Path to folder containing video files')
    pipeline.add_argument('--style', choices=['basic', 'enhanced'], default='enhanced', 
                         help='Edit style (default: enhanced)')
    pipeline.add_argument('--project-name', help='Custom DaVinci Resolve project name')
    pipeline.add_argument('--dry-run', action='store_true', help='Skip timeline building')
    
    # Individual commands
    ingest = subparsers.add_parser('ingest', help='Scan folder and extract metadata')
    ingest.add_argument('folder', help='Path to folder containing video files')
    
    transcribe = subparsers.add_parser('transcribe', help='Generate transcripts')
    transcribe.add_argument('manifest', help='Path to manifest.json file')
    
    script = subparsers.add_parser('script', help='Generate edit plan')
    script.add_argument('manifest', help='Path to manifest.json file')
    script.add_argument('transcripts', help='Path to transcripts directory')
    script.add_argument('--style', choices=['basic', 'enhanced'], default='enhanced')
    script.add_argument('--output', help='Custom output path for edit plan')
    
    timeline = subparsers.add_parser('timeline', help='Build DaVinci Resolve timeline')
    timeline.add_argument('edit_plan', help='Path to edit_plan.json file')
    timeline.add_argument('manifest', help='Path to manifest.json file')
    timeline.add_argument('--project-name', help='Custom project name')
    
    analyze = subparsers.add_parser('analyze', help='Analyze footage usage')
    analyze.add_argument('manifest', help='Path to manifest.json file')
    analyze.add_argument('edit_plan', help='Path to edit_plan.json file')
    
    status = subparsers.add_parser('status', help='Check system status')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    try:
        if args.command == 'status':
            return cmd_status()
        elif args.command == 'ingest':
            return cmd_ingest(args.folder)
        elif args.command == 'transcribe':
            return cmd_transcribe(args.manifest)
        elif args.command == 'script':
            return cmd_script(args.manifest, args.transcripts, args.style, args.output)
        elif args.command == 'timeline':
            return cmd_timeline(args.edit_plan, args.manifest, args.project_name)
        elif args.command == 'analyze':
            return cmd_analyze(args.manifest, args.edit_plan)
        elif args.command == 'pipeline':
            return cmd_pipeline(args.folder, args.style, args.project_name, args.dry_run)
    except Exception as e:
        print(f"âŒ Error: {e}", file=sys.stderr)
        return 1

def cmd_status():
    """Check system prerequisites."""
    print("ğŸ¬ DaVinci Resolve Video Pipeline Status")
    print("=" * 40)
    
    # Check DaVinci Resolve
    resolve = get_resolve()
    if resolve:
        try:
            project = resolve.GetProjectManager().GetCurrentProject()
            project_name = project.GetName() if project else "None"
            print(f"âœ… DaVinci Resolve: Connected")
            print(f"   Current project: {project_name}")
        except Exception as e:
            print(f"âš ï¸  DaVinci Resolve: Connected but error getting project: {e}")
    else:
        print("âŒ DaVinci Resolve: Not running or not accessible")
    
    # Check OpenAI API key
    api_key = os.getenv('OPENAI_API_KEY')
    if api_key:
        print(f"âœ… OpenAI API: Key configured ({api_key[:8]}...)")
    else:
        print("âŒ OpenAI API: No API key found (set OPENAI_API_KEY)")
    
    # Check ffprobe
    if os.system('which ffprobe > /dev/null 2>&1') == 0:
        print("âœ… ffprobe: Available")
    else:
        print("âŒ ffprobe: Not found (install with 'brew install ffmpeg')")
    
    return 0

def cmd_ingest(folder_path):
    """Ingest footage from folder."""
    if not os.path.exists(folder_path):
        raise FileNotFoundError(f"Folder not found: {folder_path}")
    
    print(f"ğŸ“ Scanning folder: {folder_path}")
    manifest = scan_folder(folder_path)
    manifest_path = os.path.join(folder_path, "manifest.json")
    save_manifest(manifest, manifest_path)
    
    print(f"âœ… Ingested {manifest['total_clips']} clips ({manifest['total_duration_minutes']:.1f} min)")
    print(f"   Manifest saved: {manifest_path}")
    return 0

def cmd_transcribe(manifest_path):
    """Generate transcripts."""
    if not os.path.exists(manifest_path):
        raise FileNotFoundError(f"Manifest not found: {manifest_path}")
    
    print(f"ğŸ¤ Transcribing audio from: {manifest_path}")
    transcripts = transcribe_project(manifest_path)
    
    success_count = len([t for t in transcripts.values() if t])
    total_count = len(transcripts)
    
    print(f"âœ… Transcribed {success_count}/{total_count} clips")
    print(f"   Transcripts saved: {os.path.dirname(manifest_path)}/_transcripts/")
    return 0

def cmd_script(manifest_path, transcripts_dir, style, output_path):
    """Generate edit script."""
    if not os.path.exists(manifest_path):
        raise FileNotFoundError(f"Manifest not found: {manifest_path}")
    if not os.path.exists(transcripts_dir):
        raise FileNotFoundError(f"Transcripts directory not found: {transcripts_dir}")
    
    print(f"ğŸ¤– Generating {style} edit script...")
    
    if style == 'enhanced':
        edit_plan = generate_enhanced_edit_plan(manifest_path, transcripts_dir, output_path)
    else:
        edit_plan = generate_edit_plan(manifest_path, transcripts_dir, output_path)
    
    if not edit_plan:
        raise Exception("Failed to generate edit plan")
    
    sections = len(edit_plan.get("sections", []))
    total_clips = sum(len(s.get("clips", [])) for s in edit_plan.get("sections", []))
    broll_clips = sum(1 for s in edit_plan.get("sections", []) for c in s.get("clips", []) if c.get("role") == "broll")
    broll_pct = round(broll_clips/total_clips*100, 1) if total_clips > 0 else 0
    
    print(f"âœ… Generated edit plan: {edit_plan.get('title', 'Untitled')}")
    print(f"   {sections} sections, {total_clips} clips, {broll_pct}% B-roll")
    print(f"   Estimated duration: {edit_plan.get('estimated_duration_seconds', 0)//60:.0f}:{edit_plan.get('estimated_duration_seconds', 0)%60:02.0f}")
    
    final_path = output_path or os.path.join(os.path.dirname(manifest_path), f"edit_plan{'_enhanced' if style=='enhanced' else ''}.json")
    print(f"   Plan saved: {final_path}")
    return 0

def cmd_timeline(edit_plan_path, manifest_path, project_name):
    """Build timeline in DaVinci Resolve."""
    if not os.path.exists(edit_plan_path):
        raise FileNotFoundError(f"Edit plan not found: {edit_plan_path}")
    if not os.path.exists(manifest_path):
        raise FileNotFoundError(f"Manifest not found: {manifest_path}")
    
    # Check Resolve connection
    resolve = get_resolve()
    if not resolve:
        raise Exception("Cannot connect to DaVinci Resolve. Is it running?")
    
    print(f"ğŸ¬ Building timeline from: {edit_plan_path}")
    timeline = build_timeline_from_plan(edit_plan_path, manifest_path, project_name)
    
    if timeline:
        print(f"âœ… Timeline created: {timeline.GetName()}")
        print(f"   Video tracks: {timeline.GetTrackCount('video')}")
        print(f"   Audio tracks: {timeline.GetTrackCount('audio')}")
    else:
        raise Exception("Failed to create timeline")
    
    return 0

def cmd_analyze(manifest_path, edit_plan_path):
    """Analyze footage usage."""
    if not os.path.exists(manifest_path):
        raise FileNotFoundError(f"Manifest not found: {manifest_path}")
    if not os.path.exists(edit_plan_path):
        raise FileNotFoundError(f"Edit plan not found: {edit_plan_path}")
    
    # Load data for basic analysis
    with open(manifest_path) as f:
        manifest = json.load(f)
    with open(edit_plan_path) as f:
        plan = json.load(f)
    
    all_clips = len(manifest["clips"])
    used_clips = set()
    for section in plan.get("sections", []):
        for clip_info in section.get("clips", []):
            used_clips.add(clip_info["filename"])
    
    unused_count = all_clips - len(used_clips)
    usage_pct = round(len(used_clips)/all_clips*100, 1)
    
    print(f"ğŸ“Š Footage Usage Analysis")
    print(f"   Total clips: {all_clips}")
    print(f"   Used clips: {len(used_clips)} ({usage_pct}%)")
    print(f"   Unused clips: {unused_count}")
    
    if unused_count > 0:
        print(f"   ğŸ’¡ {unused_count} clips available for additional B-roll!")
    
    return 0

def cmd_pipeline(folder_path, style, project_name, dry_run):
    """Run complete pipeline."""
    if not os.path.exists(folder_path):
        raise FileNotFoundError(f"Folder not found: {folder_path}")
    
    print(f"ğŸš€ Starting {style} video editing pipeline...")
    print(f"   Source: {folder_path}")
    if project_name:
        print(f"   Project: {project_name}")
    if dry_run:
        print("   Mode: Dry run (no timeline creation)")
    print()
    
    # Step 1: Ingest
    print("Step 1/4: Ingesting footage...")
    manifest_path = os.path.join(folder_path, "manifest.json")
    if not os.path.exists(manifest_path):
        cmd_ingest(folder_path)
    else:
        print(f"   Using existing manifest: {manifest_path}")
    
    # Step 2: Transcribe  
    print("\nStep 2/4: Transcribing audio...")
    transcripts_dir = os.path.join(folder_path, "_transcripts")
    if not os.path.exists(transcripts_dir):
        cmd_transcribe(manifest_path)
    else:
        print(f"   Using existing transcripts: {transcripts_dir}")
    
    # Step 3: Generate script
    print(f"\nStep 3/4: Generating {style} edit script...")
    edit_plan_path = os.path.join(folder_path, f"edit_plan{'_enhanced' if style=='enhanced' else ''}.json")
    if not os.path.exists(edit_plan_path):
        cmd_script(manifest_path, transcripts_dir, style, edit_plan_path)
    else:
        print(f"   Using existing edit plan: {edit_plan_path}")
    
    # Step 4: Build timeline
    if dry_run:
        print("\nStep 4/4: Skipping timeline creation (dry run)")
    else:
        print("\nStep 4/4: Building DaVinci Resolve timeline...")
        cmd_timeline(edit_plan_path, manifest_path, project_name)
    
    # Summary
    print("\nğŸ‰ Pipeline complete!")
    with open(manifest_path) as f:
        manifest = json.load(f)
    
    print(f"   ğŸ“ Processed {manifest['total_clips']} clips ({manifest['total_duration_minutes']:.1f} min)")
    print(f"   ğŸ¬ Timeline ready in DaVinci Resolve")
    print(f"   ğŸ“‹ Next: Review, adjust, and export your video!")
    
    return 0

if __name__ == '__main__':
    exit(main())